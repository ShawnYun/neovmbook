# AVM从何而来-模块化和汇编器

之前一直在提到 汇编器，在流程说明中，我们没有认真的讨论这个问题

## 模块化

我们知道NEOVM是图灵机的一种实现，可是图灵机就是磁带机，标准的磁带机可是没有模块化的。

你想想以前的磁带机听音乐，你能不能简单的一键跳到下一首歌。

以歌为单位组织数据，就是模块化。CD可以，磁带不行

但是软件工程实践中，第一重要的课题，就是模块化。

高级语言当然是模块化的，函数是最流行的模块化单位，后来随着oop的流行，类又产生了。

但是早在高级语言没有流行之前，软件工程师们，就是模块化工作的。

## 在机器语言中是如何实现模块化的

在机器中，有的只是一块指令区，而指令区中的模块化，就是通过内存区域来划定的，如果你学习过最古老的Basic语言，只有一个代码文件那种，也没有函数支持，我们就采用 



```
goto [linenum]
```

这种方式来实现模块化，让代码的不同区域实现不同的功能

这个问题放到NEOVM里面来说，我们通过 JMP 指令 和 CALL 指令来实现代码的模块化


## CALL 指令

我们来考虑一段AVM代码
```
    0x00    PUSH 1
    0x01    PUSH 2
    0x03    CALL +4
    0x06    RET
    0x07    ADD
    0x08    RET
```
实际上他就被分为了两个模块
    0x00~0x06 是 Main模块，0x07~0x08 是 ADD 模块

在没有模块化工具辅助的时候，工程师必须自己规划好模块在内存中如何划分，这是一个很繁琐的工作，有模块化，才有软件工程。


## 连接器Linker

既然模块化那么重要，那自然需要有一个模块化的辅助工具。

现在我们有一个汇编器项目了

https://github.com/neo-project/neo-vm/tree/Branch_neoasm/src/neo-asm

如果我们用我们定义的ASML语言带模块化的来表达他就是

```
Main()
{
    PUSH 1//push 1 number
    PUSH 2
    CALL method1
    RET;
}
method1()
{
    ADD
    RET
}
```

工程师们一个模块一个模块的思考与编写代码，而不再考虑哪个内存块是哪个模块。

考虑模块和地址转换关系的工作通常称为连接(Link)

比如c++语言就有一个非常明确独立的连接过程

CALL 指令是用来做函数级别的模块化

JMP 指令用于函数内部的模块化


我们的汇编器具有连接器的功能，它可以自动连接这两个模块，给他们分配合适的地址段，并让CALL的参数自动指向该指的地方。


现在是汇编，下一步是高级语言，这个过程都是一样的，必经之路。

编译器的最后工作就是地址转换，它包括给模块分配地址区域，和给CALL指令提供正确地址，生成最终的AVM byte[].

因为我们的汇编器有模块化和Linker的工作，接下去我们解释编译的过程就变成两部分。

高级语言->AVML->byte[]

或者 其它虚拟机中间语言 比如 IL->AVML->byte[]

不再赘述其它编译器如何处理Linker的工作。


## JMP指令

说过了CALL 指令，再来说一下JMP指令

思考这样的代码


```
int a=1;
if(a)
{
    //aaa
}
else
{
    //bbb
}

```

aaa 和 bbb 就是两个函数内部的子模块了

如果没有模块化的表达，就是这样的，我们还是要处理地址
```
0x00 PUSH 1
0x01 JMPIF +3
0x02 PUSH 1
0x03 RET
0x04 PUSH 8
0x05 RET
```

如果用我们定义的有模块化的ASML来表示
```
Main()
{
    PUSH 1
    JMPIF label1
    PUSH 1
    RET
label1:
    PUSH 8
    RET    
}
```

不用关心地址了，引入了一个标签作为跳转位置

高级语言向汇编语言的转换过程，80%的工作就是各种loops 变成 JMP的过程

忽略掉JMP 和 CALL 指令的地址转换工作，这个工作留给Linker，下一篇我们就来讨论高级语言如何编译成NEOVM 指令